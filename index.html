<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Salma Runner â€” Stiker Edition</title>

<!-- Font lucu -->
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Baloo+2:wght@400;700&display=swap" rel="stylesheet">

<style>
  :root{
    --bg1:#cfeef8;
    --bg2:#fff1f6;
    --ground:#e8d7c2;
    --accent:#8b5e3c;
    --pink:#ff6f91;
  }
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Baloo 2", "Fredoka One", sans-serif;background:linear-gradient(180deg,var(--bg1),var(--bg2));display:flex;align-items:center;justify-content:center}
  #wrap{width:100%;max-width:900px;padding:20px;box-sizing:border-box}
  .panel{background:rgba(255,255,255,0.6);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(15,15,15,0.06)}
  .title{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .title h1{margin:0;font-family:"Fredoka One",sans-serif;color:var(--accent);font-size:18px}
  .hud{display:flex;gap:8px;align-items:center}
  .pill{background:#fff;padding:6px 8px;border-radius:999px;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,0.06)}
  /* canvas box */
  .gamebox{position:relative;width:100%;height:260px;overflow:hidden;border-radius:10px;background:linear-gradient(180deg,#bde6ff,#fff6f8);display:flex;align-items:flex-end}
  canvas{display:block;width:100%;height:100%}
  /* run button */
  #runBtn{
    position:absolute;right:18px;bottom:18px;width:72px;height:72px;border-radius:50%;
    background:linear-gradient(180deg,var(--accent),#744b2b);color:#fff;font-weight:800;border:none;
    box-shadow:0 8px 18px rgba(0,0,0,0.18);font-size:14px;touch-action:manipulation;
  }
  /* stamina display circle */
  #staminaWrap{position:absolute;left:14px;bottom:18px;width:96px;height:72px;display:flex;flex-direction:column;align-items:flex-start;gap:6px}
  .stBox{background:rgba(255,255,255,0.85);padding:6px 8px;border-radius:10px;box-shadow:0 6px 14px rgba(0,0,0,0.06);font-weight:700}
  .scoreBox{position:absolute;right:18px;top:14px;background:rgba(255,255,255,0.9);padding:6px 10px;border-radius:12px;font-weight:800}
  .small{font-size:12px;color:#444}
  @media (max-width:420px){
    .gamebox{height:220px}
    #runBtn{width:60px;height:60px}
  }
</style>
</head>
<body>
<div id="wrap">
  <div class="panel">
    <div class="title">
      <h1>Salma Runner â€” Stiker</h1>
      <div class="hud">
        <div class="pill small">Mode: Stiker Chat</div>
      </div>
    </div>

    <div class="gamebox" id="gamebox">
      <canvas id="c"></canvas>

      <div id="staminaWrap">
        <div class="stBox small" id="stText">Energi: 100%</div>
        <div style="width:92px;height:8px;background:rgba(0,0,0,0.06);border-radius:8px;overflow:hidden">
          <div id="stBar" style="height:100%;width:100%;background:linear-gradient(90deg,var(--pink),#ffb3d1)"></div>
        </div>
      </div>

      <div class="scoreBox" id="scoreBox">Skor: 0</div>

      <button id="runBtn">LARI</button>
    </div>
  </div>
</div>

<script>
/* ---------- Setup & performance-friendly canvas ---------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });
const box = document.getElementById('gamebox');
let CSS_W = box.clientWidth;
let CSS_H = box.clientHeight;

// internal resolution (keeps performance): scale factor
const SCALE = window.devicePixelRatio > 1.5 ? 1.5 : 1;
function resize(){
  CSS_W = box.clientWidth; CSS_H = box.clientHeight;
  canvas.style.width = CSS_W + 'px';
  canvas.style.height = CSS_H + 'px';
  canvas.width = Math.floor(CSS_W * SCALE);
  canvas.height = Math.floor(CSS_H * SCALE);
  ctx.setTransform(SCALE,0,0,SCALE,0,0);
}
window.addEventListener('resize', resize);
resize();

/* ---------- Game variables ---------- */
let gameSpeed = 6;            // base speed (pixels per frame scale)
let baseSpeed = 6;
let spawnInterval = 1500;     // ms between obstacles spawn
let lastSpawn = 0;
let lastRival = 0;
let rivalInterval = 3800;

let score = 0;
let startTime = performance.now();

let stamina = 100;
const MAX_STAMINA = 100;
const STAMINA_USE = 0.9;
const STAMINA_REGEN = 0.45;
let sprinting = false;

const scoreBox = document.getElementById('scoreBox');
const stText = document.getElementById('stText');
const stBar = document.getElementById('stBar');
const runBtn = document.getElementById('runBtn');

runBtn.addEventListener('touchstart', e => { e.preventDefault(); sprinting = true; });
runBtn.addEventListener('touchend', e => { e.preventDefault(); sprinting = false; });
runBtn.addEventListener('mousedown', e => { sprinting = true; });
runBtn.addEventListener('mouseup', e => { sprinting = false; });
runBtn.addEventListener('mouseleave', e => { sprinting = false; });

// tap to jump
let wantJump = false;
window.addEventListener('touchstart', (e)=>{
  // avoid firing when touching the runBtn: check target
  if(e.target === runBtn) return;
  wantJump = true;
});
window.addEventListener('mousedown', (e)=>{
  if(e.target === runBtn) return;
  wantJump = true;
});

/* ---------- World ---------- */
const groundY = CSS_H - 48;
let bgOffset = 0;

/* ---------- Salma sprite (sticker style) - drawn procedurally ---------- */
const salma = {
  x: 90, w: 72, h: 72,
  y: 0, dy: 0, onGround: true,
  state: 'run', // run, jump
  face: 'normal' // normal or crying
};

salma.y = groundY - salma.h;

/* create tiny offscreen canvases for sticker-ish sprites to avoid redraw cost */
function makeSticker(normalColor, eyeColor, crying=false){
  const s = document.createElement('canvas');
  s.width = 160; s.height = 160;
  const r = s.getContext('2d');
  r.scale(1,1);
  // circular head + body sticker
  r.fillStyle = '#fff';
  r.beginPath(); r.roundRect(8,8,144,144,20); r.fill();
  // face oval
  r.fillStyle = normalColor;
  r.beginPath(); r.ellipse(80,68,44,50,0,0,Math.PI*2); r.fill();
  // eyes
  r.fillStyle = eyeColor; r.beginPath(); r.ellipse(65,68,6,8,0,0,Math.PI*2); r.fill();
  r.beginPath(); r.ellipse(95,68,6,8,0,0,Math.PI*2); r.fill();
  // mouth
  r.fillStyle = '#6b3b3b';
  r.beginPath(); r.ellipse(80,92,12,6,0,0,Math.PI); r.fill();
  // cheeks
  r.fillStyle = 'rgba(255,110,150,0.18)';
  r.beginPath(); r.ellipse(60,82,9,6,0,0,Math.PI*2); r.fill();
  r.beginPath(); r.ellipse(100,82,9,6,0,0,Math.PI*2); r.fill();
  // crying tears if crying==true (small, separate)
  if(crying){
    r.fillStyle = 'rgba(120,200,255,0.95)';
    r.beginPath(); r.ellipse(68,88,5,9,0,0,Math.PI*2); r.fill();
    r.beginPath(); r.ellipse(92,88,5,9,0,0,Math.PI*2); r.fill();
  }
  return s;
}

// build stickers: normal and crying variant
const stickerNormal = makeSticker('#ffd6e6','#3b2b2b', false);
const stickerCrying = makeSticker('#ffd6e6','#3b2b2b', true);

/* tears particles (animated while sprinting) */
let tears = [];

/* ---------- Obstacles (Masalah Hidup) ---------- */
let obstacles = [];
let obstacleCount = 0;

function spawnObstacle(){
  obstacleCount++;
  const w = 56;
  const h = 56;
  const y = groundY - h;
  const o = {
    x: canvas.width / SCALE + 40,
    y: y,
    w: w,
    h: h,
    id: obstacleCount,
    icon: randomIcon()
  };
  obstacles.push(o);
}

function randomIcon(){
  // Return a function that draws a simple icon on ctx with scale
  const pick = Math.floor(Math.random()*4);
  return pick; // we'll draw based on id
}

/* ---------- Rivals (Farhant) - simple sticker bounce ---------- */
let rivals = [];
function spawnRival(){
  const r = {
    x: canvas.width / SCALE + 40,
    y: groundY - 72 - Math.random()*40,
    w: 64, h:64,
    vy: -10,
    landed: false
  };
  rivals.push(r);
}

/* ---------- collision helper ---------- */
function rectCollide(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

/* ---------- Main update/draw ---------- */
let last = performance.now();
function frame(ts){
  const dt = Math.min(0.05, (ts - last) / 1000);
  last = ts;

  // update background offset
  const speedMultiplier = 1 + ((MAX_STAMINA - stamina) / MAX_STAMINA) * 0.45; // small dynamic
  let curSpeed = baseSpeed * (sprinting ? 1.9 : 1.0) * speedMultiplier;
  bgOffset = (bgOffset + curSpeed * 40 * dt) % (canvas.width / SCALE);

  // spawn obstacles
  if(ts - lastSpawn > spawnInterval){
    spawnObstacle();
    lastSpawn = ts;
  }
  if(ts - lastRival > rivalInterval + Math.random()*1500){
    spawnRival();
    lastRival = ts;
  }

  // stamina logic
  if(sprinting && stamina > 0){
    stamina = Math.max(0, stamina - STAMINA_USE * dt * 60);
    // spawn tears particles slowly
    if(Math.random() < 0.5) tears.push({x: salma.x + salma.w - 12, y: salma.y + salma.h - 6, vy: 80 + Math.random()*30, t:0});
    salma.face = 'crying';
  } else {
    stamina = Math.min(MAX_STAMINA, stamina + STAMINA_REGEN * dt * 60);
    salma.face = 'normal';
  }

  // jump logic
  if(wantJump){
    if(salma.onGround){
      salma.dy = -14;
      salma.onGround = false;
      salma.state = 'jump';
      // burst hearts on jump (love)
      for(let i=0;i<6;i++){
        const angle = (Math.PI*2) * (i/6);
        tears.push({isLove:true,x:salma.x+salma.w/2,y:salma.y+12, vx: Math.cos(angle)*35 + (Math.random()*20-10), vy: -120 + Math.random()*-20, s:1 + Math.random()*0.6, t:0});
      }
    }
    wantJump = false; // single tap jump
  }

  // physics
  salma.dy += 35 * dt;
  salma.y += salma.dy;
  if(salma.y + salma.h >= groundY){
    salma.y = groundY - salma.h;
    salma.dy = 0;
    salma.onGround = true;
    salma.state = 'run';
  }

  // update obstacles & rivals positions
  for(let o of obstacles){ o.x -= curSpeed * 60 * dt; }
  obstacles = obstacles.filter(o => o.x + o.w > -40);

  for(let r of rivals){
    if(!r.landed){
      r.vy += 40 * dt;
      r.y += r.vy;
      r.x -= curSpeed * 60 * dt * 0.9;
      if(r.y + r.h >= groundY){
        r.y = groundY - r.h; r.vy = 0; r.landed = true;
      }
    } else {
      r.x -= curSpeed * 60 * dt * 0.9;
    }
  }
  rivals = rivals.filter(r => r.x + r.w > -80);

  // update tears (particles) - both tears and love bits
  for(let p of tears){
    p.t += dt;
    if(!p.isLove){
      p.y += p.vy * dt;
      p.vy += 240 * dt;
    } else {
      p.x += (p.vx || 0) * dt;
      p.y += (p.vy || 0) * dt;
      p.vy += 240 * dt;
      p.s *= 0.98;
    }
  }
  tears = tears.filter(p => p.y < canvas.height / SCALE + 80 && (p.s === undefined || p.s > 0.15) && p.t < 4);

  // scoring
  score += (curSpeed / 60) * 10 * dt * 60;
  scoreBox.textContent = 'Skor: ' + Math.floor(score);

  // update stamina UI
  stText.textContent = 'Energi: ' + Math.max(0, Math.round((stamina / MAX_STAMINA) * 100)) + '%';
  stBar.style.width = Math.max(0, (stamina / MAX_STAMINA) * 100) + '%';

  // collisions (player vs obstacle)
  for(let o of obstacles){
    if(rectCollide({x: salma.x, y: salma.y, w: salma.w, h: salma.h}, o)){
      // collision: penalize score and push obstacle away a bit (no death)
      score = Math.max(0, score - 40);
      o.x += 120;
    }
  }

  // player vs rival collision -> tag (fun)
  for(let r of rivals){
    if(rectCollide({x: salma.x, y: salma.y, w: salma.w, h: salma.h}, r)){
      score += 25;
      // create pop confetti
      for(let i=0;i<12;i++){
        tears.push({x: r.x + r.w/2, y: r.y + r.h/2, vx: (Math.random()*200-100), vy: (Math.random()*-200), s:0.9 + Math.random()*0.6, t:0});
      }
      r.x -= 260; // push away
    }
  }

  draw();

  requestAnimationFrame(frame);
}

/* ---------- Draw function ---------- */
function draw(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // scaled coordinate convenience
  const W = canvas.width / SCALE;
  const H = canvas.height / SCALE;

  // background: repeating hills stripes (simple parallax)
  ctx.save();
  // sky handled by body bg; draw simple patterned ground
  // draw far hills
  ctx.fillStyle = '#d3fff0';
  for(let i=-1;i<6;i++){
    const hx = ((i*260) - (bgOffset*0.2)) % (W+300) - 150;
    ctx.beginPath();
    ctx.ellipse(hx, H - 110, 160, 70, 0, 0, Math.PI*2);
    ctx.fill();
  }
  // mid ground (dotted path)
  ctx.fillStyle = '#fff0f2';
  for(let i=-1;i<8;i++){
    const px = (i*140 - (bgOffset*0.5)) % (W+200) - 100;
    ctx.fillRect(px, H-74, 80, 8);
  }
  ctx.restore();

  // ground strip
  ctx.fillStyle = 'rgba(232,215,194,0.98)';
  ctx.fillRect(0, H - 48, W, 48);

  // obstacles
  for(let o of obstacles){
    // icon background bubble
    ctx.save();
    ctx.translate(o.x, o.y);
    ctx.fillStyle = '#fff';
    roundRect(ctx, 0, 0, o.w, o.h, 10);
    ctx.fill();
    // icon: draw different little pictos
    drawObstacleIcon(ctx, o.icon, o.w, o.h);
    // label under icon
    ctx.fillStyle = '#2b2b2b';
    ctx.font = Math.max(11,12) + 'px "Baloo 2", "Fredoka One", sans-serif';
    ctx.fillText('Masalah Hidup ' + o.id, 4, o.h - 6);
    ctx.restore();
  }

  // rivals (sticker small)
  for(let r of rivals){
    ctx.save();
    ctx.translate(r.x, r.y);
    // draw white rounded sticker background
    ctx.fillStyle = '#fff';
    roundRect(ctx, 0, 0, r.w, r.h, 12);
    ctx.fill();
    // simple face (Farhant placeholder)
    ctx.fillStyle = '#9ad1ff';
    ctx.beginPath(); ctx.ellipse(r.w/2, r.h/2 - 6, r.w*0.34, r.h*0.34, 0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.fillRect(r.w/2 + 6, r.h/2 - 4, 6, 6);
    ctx.restore();
  }

  // draw salma sticker (choose normal or crying)
  ctx.save();
  const sx = salma.x, sy = salma.y;
  if(salma.face === 'crying'){
    ctx.drawImage(stickerCrying, sx - 8, sy - 8, salma.w + 16, salma.h + 16);
  } else {
    ctx.drawImage(stickerNormal, sx - 8, sy - 8, salma.w + 16, salma.h + 16);
  }
  ctx.restore();

  // draw tears & love particles
  for(let p of tears){
    if(p.isLove){
      ctx.save(); ctx.fillStyle = 'rgba(255,110,150,' + Math.max(0.05, 1 - p.t/1.4) + ')';
      heart(ctx, p.x, p.y, 6 * (p.s || 1));
      ctx.restore();
    } else {
      ctx.save();
      ctx.fillStyle = 'rgba(120,200,255,' + Math.max(0.06, 1 - p.t/1.4) + ')';
      ctx.beginPath();
      ctx.ellipse(p.x, p.y, 3, 7, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // HUD overlays (score & stamina are DOM elements)
}

/* ---------- helpers for drawing ---------- */
function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

function drawObstacleIcon(ctx, type, w, h){
  ctx.save();
  ctx.translate(0,0);
  ctx.fillStyle = '#ffefc7';
  // simple pictos: 0 = report, 1 = chat, 2 = alarm, 3 = rock
  ctx.fillStyle = '#fdf2ff';
  roundRect(ctx, 6, 6, w - 12, h - 18, 8);
  ctx.fill();
  ctx.fillStyle = '#6b3b3b';
  ctx.font = 'bold 18px "Baloo 2", sans-serif';
  if(type === 0){
    ctx.fillText('ðŸ“„', w/2 - 9, h/2 + 2);
  } else if(type === 1){
    ctx.fillText('ðŸ’¬', w/2 - 9, h/2 + 2);
  } else if(type === 2){
    ctx.fillText('â°', w/2 - 9, h/2 + 2);
  } else {
    ctx.fillText('ðŸª¨', w/2 - 9, h/2 + 2);
  }
  ctx.restore();
}

function heart(ctx,x,y,size){
  ctx.beginPath();
  const topY = y - size * 0.5;
  ctx.moveTo(x, topY);
  ctx.bezierCurveTo(x, topY - size*0.7, x - size, topY - size*0.7, x - size, topY + size*0.2);
  ctx.bezierCurveTo(x - size, topY + size*1.1, x, topY + size*1.4, x, topY + size*1.9);
  ctx.bezierCurveTo(x, topY + size*1.4, x + size, topY + size*1.1, x + size, topY + size*0.2);
  ctx.bezierCurveTo(x + size, topY - size*0.7, x, topY - size*0.7, x, topY);
  ctx.closePath();
  ctx.fill();
}

/* ---------- utility: launch loop ---------- */
requestAnimationFrame(frame);

/* ---------- expose resize for initial groundY update ---------- */
window.addEventListener('resize', ()=> {
  resize();
});

/* ---------- small polyfills for roundRect on context if needed ---------- */
if(!CanvasRenderingContext2D.prototype.roundRect){
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    if(!r) r = 6;
    this.beginPath();
    this.moveTo(x + r, y);
    this.arcTo(x + w, y, x + w, y + h, r);
    this.arcTo(x + w, y + h, x, y + h, r);
    this.arcTo(x, y + h, x, y, r);
    this.arcTo(x, y, x + w, y, r);
    this.closePath();
  };
}
</script>
</body>
</html>
